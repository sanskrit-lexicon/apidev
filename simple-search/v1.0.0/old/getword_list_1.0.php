<?php
/*
 getword_list_0.1.php  
 Variant of getword_list_1.0.php of fetching_v0.3b.
 Designed to work with list-0.2s.html
  06-01-2017. based on apidev/getword_xml.php
  'key' is treated as a comma-delimited list of keys
  Retrieves info for a given headword; retrieves from web/sqlite/<dict>.xml
  Enhancement:  retrieve multiple headwords
  Enhancement:  retrieve based on normalized spelling
  06-02-2017. In this version, the variants are generated by php, rather
        than being pregenerated by javascript
  06-05-2017. Compute variants with SLP
*/
header("Access-Control-Allow-Origin: *");
header('content-type: application/json; charset=utf-8');
//if (isset($_GET['callback'])) {
//}
$dirpfx = "../../";
$dbg = false;
//require_once('dbgprint.php');
require_once($dirpfx . "utilities/transcoder.php"); // initializes transcoder
require_once($dirpfx . "dal.php");  
require_once($dirpfx . 'dbgprint.php');
// 
require_once('simple_search.php');
// class to access the hwnorm1 database
require_once('dalnorm.php');

// access parameters from $_REQUEST
require_once($dirpfx . "parm.php");
$getParms = new Parm();
dbgprint($dbg,"Entering getword_list_1.0.php 4\n");

// Part of the simple search algorithm depends on the 
// dictionary
$dict = $getParms->dict;
dbgprint($dbg,"getword_list_1.0.php: dict=$dict\n");
$dal = new Dal($dict);
// WARNING: the relative path to sanhw1 is sensitive to location of
//   this file.
$dalnorm = new Dalnorm('hwnorm1c','../../../sanhw1');
// Ordering of results depends on a word frequency file.
$wfreqs = init_word_frequency();

// keyparmin is the key input. It is what the user requested.
//  $keyparm = $getParms->key;  // unused. keyparmin have been convert to slp1.
$keyparmin = $getParms->keyin;  // original
dbgprint($dbg,"keyparmin=$keyparmin\n");
$ans = array();  // return associative array
$ans['dict']=$dict;
$ans['input']=$getParms->filterin;  //should be 'simple'  Not of interest
$ans['output']=$getParms->filter;   // The output type for Sanskrit
$ans['accent']=$getParms->accent;   // # yes or no  Not used otherwise


//keyparmin is original. keysin is slp1
$keysin0 = generate_alternates($keyparmin); 
// normalize $keysin0, and remove duplicates
$keysin = [];
$foundkeysin = array();
foreach($keysin0 as $key) {
 $normkey = $dalnorm->normalize($key);
 if (!isset($foundkeysin[$normkey])) {
  $foundkeysin[$normkey] = true;
  $keysin[] = $normkey;
 }
}
$nkeysin = count($keysin);
dbgprint($dbg,"$keyparmin has $nkeysin alternates\n");
$result = [];  
for($ikey=0;$ikey<count($keysin);$ikey++) {
 $key = $keysin[$ikey];
 //$key = $keys[$ikey];
 //$keyin =  transcoder_processString($keyin,$ans['input'],"slp1");
 $ans1 = array();
 $ans1['key'] = $key;
 $ans1['keyin'] = 'NF';
 // initialize xml and status for failure
 $ans1['xml'] = array("NOT FOUND");
 // ref: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
 $ans1['status']=404;  // NOT FOUND use HTTP status codes. 404
 // ngram checks now done in simple_search
 /*
 $matches= $dal->get1_xml($key); 
 */
 // Use hwnorm1c
 /*
 $matches = $dalnorm->get1norm($key);
 $normkey = $dalnorm->normalize($key);
 $matches = $dalnorm->get1($normkey);
 */
 // Assume key already normalized
 $matches = $dalnorm->get1($key);
 $nmatches = count($matches);
 dbgprint($dbg,"for key=$key, nmatches1=$nmatches\n");
 if ($nmatches > 0) {
  // We know that $key is the normalized spelling of a
  //  headword in SOME dictionary
  // For this display, we further want to require that it is a headword
  // in the user-selected dictionary ($dict)
  $dictheadword = null;
  # $nmatches is either 0 or 1 for this hwnorm1c database
  for($i=0;$i<$nmatches;$i++) {
   #dbgprint(true,"$i\n");
   $rec = $matches[$i]; //($m['key'],$m['data'])
   $parts = explode(';',$rec[1]);
   $dictup = strtoupper($dict);  // dictlist below are upper
   dbgprint($dbg,"dictup=$dictup\n");
   foreach($parts as $part) {
    list($dictheadword0,$dictliststring) = explode(':',$part);
    dbgprint($dbg,"$dictheadword0  IS IN $dictliststring\n");
    $dictlist = explode(',',$dictliststring);
    if (in_array($dictup,$dictlist)) {
      $dictheadword=$dictheadword0; // It is slp1 spelling
      dbgprint($dbg,"found $dictheadword in $dictup\n");
      break;
    }
   }
   // if dictheadword is null (not in OUR dictionary), reset $nmatches to 0
   if ($dictheadword == null) {
    $nmatches = 0;
   }
  }
 }
 dbgprint($dbg,"for key=$key,final nmatches=$nmatches, $dictheadword\n");
 if ($nmatches > 0) {
  // transcode to HK for this display
  $ans1['keyin']  =  transcoder_processString($key,"slp1",$ans['input']);
  // reset xml, and status
  # accent-adjustment
  require_once($dirpfx . "accent_adjust.php");
  $dictinfo = $getParms->dictinfo;
  $dictup = $dictinfo->dictupper;
  $accent = $getParms->accent;
  $dictinfo = $getParms->dictinfo;
  $dictup  = $dictinfo->dictupper;
  
  $filter = $getParms->filter;
  $ans1['dicthw']=$dictheadword;  // slp1 spelling of $key in OUR dict
  $ans1['dicthwoutput']=transcoder_processString($dictheadword,"slp1",$ans['output']);
  $table1 = array();
  $i = 0;
  #dbgprint(true,"$i\n");
  $rec = $matches[$i]; //($m['key'],$m['data'])
  // For this work simple_search, no need to do this adjustment
  // $rec[1] is the data 
  $ans1['xml']=$rec[1];
  $ans1['status']= 200; // OK
 }
 // only return those if $nmatches>0
 if ($nmatches > 0) {
  $result[] = $ans1;
 }
}
$result1 = order_by_wf($result,$wfreqs);
$ans['result']=$result1;
$json = json_encode($ans);
if (isset($_GET['callback'])) {
 echo "{$_GET['callback']}($json)";
}else {
 echo $json;
}
exit(0);

function init_word_frequency() {
 # word_frequency_adj.txt removes duplicates from word_frequency.txt
 # see readme.org in ../v0.1
 $filein = "../v0.1/word_frequency_adj.txt";
 $lines = file($filein,FILE_IGNORE_NEW_LINES);
 $ans = array();
 $nans = 0;
 $dbg=false;
 foreach($lines as $line) {
  $line = trim($line);
  if (preg_match('|([^ ]*) *([0-9]*)$|',$line,$matches)) {
   $key = $matches[1];
   $val = $matches[2];
   //$ival = (int)$val; # python code
   $ival = intval($val);
   $ans[$key] = $ival;
   $nans = $nans + 1;
   if ($nans <= 10) {
    dbgprint($dbg,"init_word_frequency: $nans , '$key', $val, $ival\n");
   }
  }
 }
 dbgprint($dbg,"init_word_frequence. nans=$nans, value @ daRqa=" . $ans['daRqa'] . "\n");
 dbgprint($dbg,"init_word_frequence. nans=$nans, value @akaRwaka =" . $ans['akaRwaka'] . "\n");

 return $ans;
}
function wf_cmp($a,$b) {
 // $a, $b are objects: $a = $result[$i]
 if ($a['wf'] == $b['wf']) {
  return 0;
 }
 return  ($a['wf'] > $b['wf']) ? -1 : 1;
 #return  ($a['wf'] > $b['wf']) ? 1 : -1;
}
function order_by_wf($result,$wfreqs) {
 $result1 = array();
 foreach($result as $ans1) {
  $key = $ans1['key'];  // slp1, consistent with coding of word_frequency
  if (isset($wfreqs[$key])) {
   $wf = $wfreqs[$key];
  }else if ($ans1['status'] == 200) {
   $wf = -1;
  }else{
   $wf = -9;
  }
  $ans1['wf']=$wf;
  $result1[] = $ans1;
 }
 usort($result1,"wf_cmp");
 $dbg=false;
 if ($dbg) {
  dbgprint(true,"wfreqs at daRqa = " . $wfreqs['daRqa'] . "\n");
  foreach($result1 as $ans1) {
   dbgprint(true,$ans1['key'] . "  " . $ans1['wf'] . "\n");
  }
 }
 return $result1;
}
function convert_nonascii($wordin) {
 // Devanagari and IAST to HK
 if (preg_match('/^[a-zA-Z]+$/',$wordin)) {
  // no conversion needed
  return $wordin;
 }
 // transcode Devanagari to HK
 $wordin1 = transcoder_processString($wordin,'deva','slp1');
 if ($wordin1 != $wordin) {
  $wordin1 =  transcoder_processString($wordin1,'slp1','hk');
 }
 // transcode IAST to HK
 $wordin2 = transcoder_processString($wordin1,'roman','slp1');
 if ($wordin2 != $wordin1) {
  $wordin2 =  transcoder_processString($wordin2,'slp1','hk');
 }
 return $wordin2;
}
function generate_alternates($keyparmin) {
  /* Handle conversion from non-ascii here.

  */
  $wordin1 = convert_nonascii($keyparmin);
  $ssobj = new Simple_Search($wordin1);
  $keysin = $ssobj->keysin;
  return $keysin; 
}
function old_generate_alternates($wordin) {
// do some alternates peculiar to HK
 $hkalternates = generate_hkalternates($wordin);
 $keysin = [];
 foreach($hkalternates as $hkalternate) {
  $word_slp1 = transcoder_processString($hkalternate,"hk","slp1");
  $ssobj = new Simple_Search($word_slp1);
  $keysin1 = $ssobj->keysin;
  $keysin = array_merge($keysin,$keysin1);
 }
 return $keysin;
}

?>
