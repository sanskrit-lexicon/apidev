<?php
/*
 getword_list_0.1.php  
 Variant of getword_list_1.0.php of fetching_v0.3b.
 Designed to work with list-0.2s.html
  06-01-2017. based on apidev/getword_xml.php
  'key' is treated as a comma-delimited list of keys
  Retrieves info for a given headword; retrieves from web/sqlite/<dict>.xml
  Enhancement:  retrieve multiple headwords
  Enhancement:  retrieve based on normalized spelling
  06-02-2017. In this version, the variants are generated by php, rather
        than being pregenerated by javascript
  06-05-2017. Compute variants with SLP
*/
header("Access-Control-Allow-Origin: *");
header('content-type: application/json; charset=utf-8');
//if (isset($_GET['callback'])) {
//}
$dirpfx = "../../";
$dbg = false;
//$dbg = true;
require_once($dirpfx . "utilities/transcoder.php"); // initializes transcoder
require_once($dirpfx . "dal.php");  
require_once($dirpfx . 'dbgprint.php');
require_once('simple_search.php');
// class to access the hwnorm1 database
require_once('dalnorm.php');

// access parameters from $_REQUEST
require_once($dirpfx . "parm.php");
$getParms = new Parm();
dbgprint($dbg,"Entering getword_list_1.0.php 4\n");

// Part of the simple search algorithm depends on the 
// dictionary
$dict = $getParms->dict;
dbgprint($dbg,"getword_list_1.0.php: dict=$dict\n");
$dal = new Dal($dict);
// WARNING: the relative path to sanhw1 is sensitive to location of
//   this file.
$dalnorm = new Dalnorm('hwnorm1c','../../../sanhw1');
// Ordering of results depends on a word frequency file.
$wfreqs = init_word_frequency();

// keyparmin is the key input. It is what the user requested.
//  $keyparm = $getParms->key;  // unused. keyparmin have been convert to slp1.
$keyparmin = $getParms->keyin;  // original
dbgprint($dbg,"keyparmin=$keyparmin\n");

//keyparmin is original.
$ssobj = new Simple_Search($keyparmin,$dict);
$keysin = $ssobj->normkeys;  // normalized slp1 spelling

$ans = array();  // return associative array
$ans['dict']=$dict;
$ans['input']=$getParms->filterin;  //should be 'simple'  Not of interest
$ans['output']=$getParms->filter;   // The output type for Sanskrit
$ans['accent']=$getParms->accent;   // # yes or no  Not used otherwise

/* In the next step, we generate an array $result of objects 
   ($ans1 is the variable name of this object).
   We use the $ans fields dict, input, output, accent
  - Generally, there is one result object for each $key in $keysin.
  - Rather confusing - perhaps there can be no object for some
  - values of $key  (if $key does not occur in dictionary $dict).
*/
$nkeysin = count($keysin);
dbgprint($dbg,"$keyparmin has $nkeysin alternates\n");
$result = [];  
for($ikey=0;$ikey<count($keysin);$ikey++) {
 $key = $keysin[$ikey];
 $ans1 = array();
 $ans1['key'] = $key;
 $ans1['keyin'] = 'NF';
 // initialize xml and status for failure
 $ans1['xml'] = array("NOT FOUND");
 // ref: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
 $ans1['status']=404;  // NOT FOUND use HTTP status codes. 404
 // Assume key already normalized
 $matches = $dalnorm->get1($key);
 $nmatches = count($matches);
 $dictheadwords = [];
 dbgprint($dbg,"for key=$key, nmatches1=$nmatches\n");
 if ($nmatches > 0) {
  // We know that $key is the normalized spelling of a
  //  headword in SOME dictionary
  // For this display, we further want to require that it is a headword
  // in the user-selected dictionary ($dict)
  // In some rare cases (example: norm = vfti), dict=mw, there may be more
  // than 1 headword spelling (key1) (example: key1=vfti, vftti).
  # $nmatches is either 0 or 1 for this hwnorm1c database
  for($i=0;$i<$nmatches;$i++) {
   #dbgprint(true,"$i\n");
   $rec = $matches[$i]; //($m['key'],$m['data'])
   $parts = explode(';',$rec[1]);
   $dictup = strtoupper($dict);  // dictlist below are upper
   dbgprint($dbg,"dictup=$dictup\n");
   foreach($parts as $part) {
    list($dictheadword0,$dictliststring) = explode(':',$part);
    dbgprint($dbg,"$dictheadword0  IS IN $dictliststring\n");
    $dictlist = explode(',',$dictliststring);
    if (in_array($dictup,$dictlist)) {
      $dictheadwords[]=$dictheadword0; // It is slp1 spelling
      dbgprint($dbg,"found $dictheadword0 in $dictup\n");
      // break;  # DON'T break  (think of vfti example above).
    }
   }

  }
 }
 
 foreach($dictheadwords as $dictheadword) {
  // This loop doesn't execute unless $nmatches>0.
  // transcode to HK for this display
  $ans1['keyin']  =  transcoder_processString($dictheadword,"slp1",$ans['input']);
  // reset xml, and status
  # accent-adjustment
  #require_once($dirpfx . "accent_adjust.php");
  $dictinfo = $getParms->dictinfo;
  $dictup = $dictinfo->dictupper;
  $accent = $getParms->accent;
  
  $filter = $getParms->filter;
  $ans1['dicthw']=$dictheadword;  // slp1 spelling of $key in OUR dict
  $ans1['dicthwoutput']=transcoder_processString($dictheadword,"slp1",$ans['output']);
  $i = 0;
  #dbgprint(true,"$i\n");
  $rec = $matches[$i]; //($m['key'],$m['data'])
  // For this work simple_search, no need to do this adjustment
  // $rec[1] is the data 
  $ans1['xml']=$rec[1];
  $ans1['status']= 200; // OK
  $result[] = $ans1;
 }
}
$result1 = order_by_wf($result,$wfreqs);
$ans['result']=$result1;

$json = json_encode($ans);
if (isset($_REQUEST['callback'])) {
 echo "{$_REQUEST['callback']}($json)";
}else {
 echo $json;
}
exit(0);

function init_word_frequency() {
 # word_frequency_adj.txt removes duplicates from word_frequency.txt
 # see readme.org in ../v0.1
 $filein = "../v0.1/word_frequency_adj.txt";
 $lines = file($filein,FILE_IGNORE_NEW_LINES);
 $ans = array();
 $nans = 0;
 $dbg=false;
 foreach($lines as $line) {
  $line = trim($line);
  if (preg_match('|([^ ]*) *([0-9]*)$|',$line,$matches)) {
   $key = $matches[1];
   $val = $matches[2];
   //$ival = (int)$val; # python code
   $ival = intval($val);
   $ans[$key] = $ival;
   $nans = $nans + 1;
   if ($nans <= 10) {
    dbgprint($dbg,"init_word_frequency: $nans , '$key', $val, $ival\n");
   }
  }
 }
 dbgprint($dbg,"init_word_frequence. nans=$nans, value @ daRqa=" . $ans['daRqa'] . "\n");
 dbgprint($dbg,"init_word_frequence. nans=$nans, value @akaRwaka =" . $ans['akaRwaka'] . "\n");

 return $ans;
}
function wf_cmp($a,$b) {
 // $a, $b are objects: $a = $result[$i]
 if ($a['wf'] == $b['wf']) {
  return 0;
 }
 return  ($a['wf'] > $b['wf']) ? -1 : 1;
 #return  ($a['wf'] > $b['wf']) ? 1 : -1;
}
function order_by_wf($result,$wfreqs) {
 $result1 = array();
 foreach($result as $ans1) {
  $key = $ans1['key'];  // slp1, consistent with coding of word_frequency
  if (isset($wfreqs[$key])) {
   $wf = $wfreqs[$key];
  }else if ($ans1['status'] == 200) {
   $wf = -1;
  }else{
   $wf = -9;
  }
  $ans1['wf']=$wf;
  $result1[] = $ans1;
 }
 usort($result1,"wf_cmp");
 $dbg=false;
 if ($dbg) {
  dbgprint(true,"wfreqs at daRqa = " . $wfreqs['daRqa'] . "\n");
  foreach($result1 as $ans1) {
   dbgprint(true,$ans1['key'] . "  " . $ans1['wf'] . "\n");
  }
 }
 return $result1;
}




?>
